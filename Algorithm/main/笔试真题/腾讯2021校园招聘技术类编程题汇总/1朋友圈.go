/*

现在有 105 个用户，编号为 1- 105，现在已知有 m 对关系，每一对关系给你两个数 x 和 y ，代表编号为 x 的用户和编号为 y 的用户是在一个圈子中，例如： A 和 B 在一个圈子中， B 和 C 在一个圈子中，那么 A , B , C 就在一个圈子中。现在想知道最多的一个圈子内有多少个用户。

数据范围：
进阶：空间复杂度  ，时间复杂度

输入描述:
第一行输入一个整数T，接下来有T组测试数据。
对于每一组测试数据：第一行输入1个整数n，代表有n对关系。
接下来n行，每一行输入两个数x和y，代表编号为x和编号为y的用户在同一个圈子里。
1 ≤ T ≤ 10
1 ≤ n ≤ 2*106
1 ≤ x, y ≤ 105

输出描述:
对于每组数据，输出一个答案代表一个圈子内的最多人数

输入例子1:
2
4
1 2
3 4
5 6
1 6
4
1 2
3 4
5 6
7 8

输出例子1:
4
2

*/
/*
特大样例
1
470
525 144
244 773
734 467
617 118
755 589
651 667
953 830
321 91
543 425
952 41
476 749
486 601
859 237
237 953
488 209
101 201
414 151
593 418
257 281
901 498
445 533
128 173
953 987
150 111
661 571
789 441
592 509
516 501
583 65
599 918
223 115
295 865
1 73
820 375
398 572
297 589
358 86
115 335
591 995
538 597
225 895
465 361
41 6
866 858
278 543
776 381
794 529
469 692
82 681
626 471
820 233
656 862
651 641
565 625
283 573
661 41
331 17
28 59
839 703
317 29
481 238
120 678
461 795
619 631
309 991
909 921
763 41
313 895
394 417
447 657
601 613
107 921
35 846
121 698
601 825
931 581
757 868
629 636
361 237
645 555
306 81
753 57
459 133
549 935
999 480
923 145
328 297
344 547
202 989
441 923
116 897
787 186
267 136
865 913
217 226
449 300
60 357
261 473
721 793
541 645
448 616
905 393
224 701
273 721
307 829
803 607
2 451
54 876
2 591
265 729
537 25
694 651
897 961
651 256
258 921
42 283
741 696
177 337
361 657
861 721
116 723
300 21
804 654
715 211
635 703
12 113
211 713
731 286
285 501
154 108
12 285
201 423
259 209
666 901
696 753
561 349
897 331
431 951
736 775
135 42
155 276
466 701
661 169
561 893
905 640
475 95
781 621
935 803
826 898
937 933
975 311
437 457
677 116
175 354
984 272
451 131
109 297
481 717
143 713
18 998
805 953
959 798
655 906
993 389
749 559
59 897
18 665
95 370
491 36
719 746
979 417
18 301
566 109
484 451
875 841
801 457
996 837
821 201
693 485
9 441
641 811
1 989
238 371
781 521
334 809
471 715
60 21
47 688
67 757
208 437
187 392
241 491
821 61
801 185
249 569
728 825
281 928
737 439
691 535
343 192
507 36
37 221
935 1
63 295
933 364
785 601
457 901
191 772
137 831
891 961
437 501
641 672
36 841
834 401
426 920
50 961
961 583
266 743
493 377
705 753
853 811
383 171
401 522
119 515
166 605
625 255
351 805
265 395
521 939
107 767
39 257
101 581
822 941
356 17
977 197
351 126
202 529
561 905
563 281
633 959
615 1
526 209
768 868
25 121
301 921
121 981
571 716
971 17
101 985
414 19
767 851
993 501
233 881
172 336
856 401
5 389
185 359
155 23
231 961
146 443
741 86
361 287
754 38
261 441
413 721
786 259
29 90
291 451
931 811
690 971
843 905
216 125
29 401
968 464
589 673
366 980
561 881
980 567
471 845
380 809
911 989
230 857
61 426
765 1
91 939
341 977
249 845
897 259
891 835
270 101
300 681
139 756
190 107
597 131
421 849
679 426
442 213
1 340
280 969
521 56
502 41
936 501
168 409
288 361
585 1
515 601
531 639
276 667
345 3
255 361
701 577
337 785
663 954
551 865
601 97
601 975
229 147
11 710
941 692
542 401
270 271
817 617
475 605
631 562
631 101
87 421
512 731
76 996
703 663
789 85
989 917
627 870
885 65
663 264
285 301
1 831
561 285
613 3
631 266
788 865
705 301
817 1
113 529
565 401
241 784
61 443
158 171
339 557
231 962
815 767
153 826
120 109
529 766
51 106
45 283
246 857
596 793
827 889
441 688
661 825
187 113
673 361
797 537
921 401
546 526
951 638
81 601
987 832
335 537
9 22
625 971
851 521
711 435
966 121
133 129
551 91
361 531
969 145
317 917
81 457
15 513
791 137
965 81
533 943
771 81
47 689
151 715
608 461
233 675
546 582
537 933
475 385
680 563
271 670
711 35
728 593
883 843
843 421
270 777
275 290
401 873
221 146
17 462
41 521
514 764
639 983
755 881
958 127
6 438
548 977
682 345
891 459
897 401
453 540
771 241
925 809
627 353
447 51
457 81
996 965
313 81
780 660
473 779
634 173
655 561
847 283
421 128
513 210
550 666
511 609
684 457
111 358
409 437
346 201
699 71
705 821
963 176
369 793
745 161
1 289
885 175
513 950
53 258
661 315
914 516
871 201
126 976
513 39
541 548
856 233
664 696
429 209
336 239
475 749
173 201
301 637
813 686
313 316
95 580
716 781
429 997
661 451
769 13
922 827
603 835
464 449
609 581
673 245
851 93
597 601

预期结果：282
*/

package main

import "fmt"

// 并查集

type Set struct {
	roots  map[int]int
	height map[int]int
}

func (this Set) append(x, y int) {
	xRoot := this.findRoot(x)
	yRoot := this.findRoot(y)

	if xRoot == 0 && yRoot == 0 {
		this.roots[x] = y
		this.roots[y] = y // 根指向自己
		this.height[y] = 1
	} else if xRoot == 0 && yRoot != 0 {// 注意判断条件写全
		this.roots[x] = yRoot
	} else if yRoot == 0 && xRoot != 0{
		this.roots[y] = xRoot
	} else {
		if this.height[xRoot] >= this.height[yRoot] {
			this.roots[yRoot] = xRoot                                          // 注意是yRoot的根

			// for k, v := range this.roots{
			// 	if v == yRoot{
			// 		this.roots[k] = xRoot
			// 	}
			// }

			this.height[xRoot] = max(this.height[xRoot], this.height[yRoot]+1) // 注意是xRoot的高度根据xRoot和yRoot的高度发生改变
		} else {
			this.roots[xRoot] = yRoot // 注意一个根指向另一个根

			// for k, v := range this.roots{
			// 	if v == xRoot{
			// 		this.roots[k] = yRoot
			// 	}
			// }
		}
	}
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// 找父节点
func (this Set) findRoot(x int) int {
	for x != this.roots[x] {
		x = this.roots[x]
	}
	return x
}

// 最多结点的集合
func (this Set) maxCount() int {
	count := make(map[int]int)
	for k := range this.roots {
		count[this.findRoot(k)]++ // 注意这里的findRoot
	}

	// for _, v := range this.roots{
	// 	count[v]++
	// }

	res := 0
	for _, v := range count {
		res = max(res, v)
	}
	return res
}

func main() {

	var T int
	fmt.Scan(&T)
	for ; T != 0; T-- {
		set := Set{map[int]int{}, map[int]int{}}
		var n int
		fmt.Scan(&n)
		for ; n != 0; n-- {
			var x, y int
			fmt.Scan(&x, &y)
			set.append(x, y)
		}
		fmt.Println(set.maxCount())
	}
}

// 我的题解：不完全正确
//
// func isInSets(sets [][]int, x int) int {
// 	for i, set := range sets {
// 		for _, num := range set {
// 			if num == x {
// 				return i
// 			}
// 		}
// 	}
// 	return -1 // 不在任何集合中
// }
//
// func main() {
// 	var T int
// 	fmt.Scan(&T)
// 	for ; T != 0; T-- {
//
// 		sets := [][]int{}
//
// 		var n int
// 		fmt.Scan(&n)
// 		for ; n != 0; n-- {
// 			var x, y int
// 			fmt.Scan(&x, &y)
// 			if len(sets) == 0 {
// 				sets = append(sets, []int{x, y})
// 				continue
// 			}
// 			xSet := isInSets(sets, x)
// 			ySet := isInSets(sets, y)
// 			if xSet == -1 && ySet == -1 {
// 				sets = append(sets, []int{x, y})
// 			} else if xSet == -1 {
// 				sets[ySet] = append(sets[ySet], x)
// 			} else if ySet == -1{
// 				sets[xSet] = append(sets[xSet], y)
// 			}else{
// 				for _, num := range sets[ySet]{
// 					sets[xSet] = append(sets[xSet], num)
// 				}
// 				sets[ySet] = []int{}
// 			}
// 		}
// 		max := 0
// 		for i := range sets{
// 			if max < len(sets[i]){
// 				max = len(sets[i])
// 			}
// 		}
// 		// fmt.Println("最终结果：", max)
// 		fmt.Println(max)
// 	}
// }
