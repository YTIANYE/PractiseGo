/**
买卖股票的最好时机(二)
  假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益

  1. 你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票

  2. 如果不能获取收益，请返回0

  3. 假设买入卖出均无手续费




  数据范围： 1 \le n \le 1 \times 10^51≤n≤1×10
5
  ， 1 \le prices[i] \le 10^41≤prices[i]≤10
4


  要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)


  进阶：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)
示例1
输入： [8,9,2,5,4,7,1]
输出： 7
说明： 在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1 在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3 在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3 总获利1+3+3=7，返回7
示例2
输入： [5,4,3,2,1]
输出： 0
说明： 由于每天股票都在跌，因此不进行任何交易最优。最大收益为0。
示例3
输入： [1,2,3,4,5]
输出： 4
说明： 第一天买进，最后一天卖出最优。中间的当天买进当天卖出不影响最终结果。最大收益为4。
 */
package main


/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 计算最大收益
 * @param prices int整型一维数组 股票每一天的价格
 * @return int整型
 */

// 100%
func maxProfit( prices []int ) int {
	// write code here

	n := len(prices)
	dp0 := make([]int, n)// 无
	dp1 := make([]int, n)// 有
	dp1[0] = -prices[0]
	for i:=1;i<n;i++ {
		price := prices[i]
		dp0[i] = max(dp0[i-1], dp1[i-1] + price)
		dp1[i] = max(dp1[i-1], dp0[i-1] - price)
	}
	return max(dp0[n-1], dp1[n-1])
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}